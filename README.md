# **АЛГОРИТМ ДЕЙКСТРЫ**
Алгори́тм Де́йкстры (англ. *Dijkstra’s algorithm*) — алгоритм на графах, изобретённый нидерландским учёным Эдсгером Дейкстрой в 1959 году. 
Находит кратчайшие пути от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса. 
Алгоритм широко применяется в программировании, например, его используют протоколы маршрутизации [OSPF](https://ru.wikipedia.org/wiki/OSPF) и [IS-IS](https://ru.wikipedia.org/wiki/IS-IS).
# **СЛОЖНОСТЬ АЛГОРИТМА**
В простейшем случае, когда для поиска вершины с минимальным *d[v]* просматривается всё множество вершин, а для хранения величин *d* используется массив, время работы алгоритма есть 
$O(n^2)$. Основной цикл выполняется порядка *n* раз, в каждом из них на нахождение минимума тратится порядка n операций. На циклы по соседям каждой посещаемой вершины тратится количество операций, 
пропорциональное количеству рёбер *m* (поскольку каждое ребро встречается в этих циклах ровно дважды и требует константное число операций). Таким образом, общее время работы алгоритма 
$O(n^{2}+m)$, но, так как $m<=n(n-1)$, оно составляет $O(n^2)$

![Блок схема алгоритма Дейкстры](https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Алгоритм_Дейкстры.pdf/page1-299px-Алгоритм_Дейкстры.pdf.jpg)

**Обозначения**
* *V* — множество вершин графа
* *E* — множество рёбер графа
* *w[ij]* — вес (длина) ребра 
* *a* — вершина, расстояния от которой ищутся
* *U* — множество посещённых вершин
* *d[u]* — по окончании работы алгоритма равно длине кратчайшего пути из *a* до вершины *u*
* *p[u]* — по окончании работы алгоритма содержит кратчайший путь из 
* *v*— текущая вершина, рассматриваемая алгоритмом

**Реализация алгоритма на языке Java**
```
class Dijkstra {
	double[] dist = new double[GV()];
	Edge[] pred = new Edge[GV()];
	public Dijkstra(WeightedDigraph G, int s) {
		boolean[] marked = new boolean[GV()];
		for (int v = 0; v <GV(); v++)
			dist[v] = Double.POSITIVE_INFINITY;
		MinPQplus<Double, Integer> pq;
		pq = new MinPQplus<Double, Integer>(); \\Priority Queue
		dist[s] = 0.0;
		pq.put(dist[s], s);
		while (!pq.isEmpty()) {
			int v = pq.delMin();
				if (marked[v]) continue;
			marked(v) = true;
			for (Edge e  (v)) {
				int w = e.to();
				if (dist[w]> dist[v] + e.weight()) {
					dist[w] = dist[v] + e.weight();
					pred[w] = e;
					pq.insert(dist[w], w);
				}
			}
		}
	}
}
```
- [ ] (for unchecked checkbox)
- [x] (for checked checkbox)
